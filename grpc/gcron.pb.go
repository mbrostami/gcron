// Code generated by protoc-gen-go. DO NOT EDIT.
// source: gcron.proto

package grpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LogEntry struct {
	GUID                 string   `protobuf:"bytes,1,opt,name=GUID,proto3" json:"GUID,omitempty"`
	Output               []byte   `protobuf:"bytes,2,opt,name=Output,proto3" json:"Output,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogEntry) Reset()         { *m = LogEntry{} }
func (m *LogEntry) String() string { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()    {}
func (*LogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd548e04c98879c7, []int{0}
}

func (m *LogEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogEntry.Unmarshal(m, b)
}
func (m *LogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogEntry.Marshal(b, m, deterministic)
}
func (m *LogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntry.Merge(m, src)
}
func (m *LogEntry) XXX_Size() int {
	return xxx_messageInfo_LogEntry.Size(m)
}
func (m *LogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntry proto.InternalMessageInfo

func (m *LogEntry) GetGUID() string {
	if m != nil {
		return m.GUID
	}
	return ""
}

func (m *LogEntry) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

type Task struct {
	FLock                bool                 `protobuf:"varint,1,opt,name=FLock,proto3" json:"FLock,omitempty"`
	FLockName            string               `protobuf:"bytes,2,opt,name=FLockName,proto3" json:"FLockName,omitempty"`
	FOverride            string               `protobuf:"bytes,3,opt,name=FOverride,proto3" json:"FOverride,omitempty"`
	FDelay               int32                `protobuf:"varint,4,opt,name=FDelay,proto3" json:"FDelay,omitempty"`
	Pid                  int32                `protobuf:"varint,5,opt,name=Pid,proto3" json:"Pid,omitempty"`
	GUID                 string               `protobuf:"bytes,6,opt,name=GUID,proto3" json:"GUID,omitempty"`
	UID                  uint32               `protobuf:"varint,7,opt,name=UID,proto3" json:"UID,omitempty"`
	Parent               string               `protobuf:"bytes,8,opt,name=Parent,proto3" json:"Parent,omitempty"`
	Hostname             string               `protobuf:"bytes,9,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Username             string               `protobuf:"bytes,10,opt,name=Username,proto3" json:"Username,omitempty"`
	Command              string               `protobuf:"bytes,11,opt,name=Command,proto3" json:"Command,omitempty"`
	StartTime            *timestamp.Timestamp `protobuf:"bytes,12,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	EndTime              *timestamp.Timestamp `protobuf:"bytes,13,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	ExitCode             int32                `protobuf:"varint,14,opt,name=ExitCode,proto3" json:"ExitCode,omitempty"`
	Output               []byte               `protobuf:"bytes,15,opt,name=Output,proto3" json:"Output,omitempty"`
	SystemTime           *duration.Duration   `protobuf:"bytes,16,opt,name=SystemTime,proto3" json:"SystemTime,omitempty"`
	UserTime             *duration.Duration   `protobuf:"bytes,17,opt,name=UserTime,proto3" json:"UserTime,omitempty"`
	Success              bool                 `protobuf:"varint,18,opt,name=Success,proto3" json:"Success,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd548e04c98879c7, []int{1}
}

func (m *Task) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Task.Unmarshal(m, b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Task.Marshal(b, m, deterministic)
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return xxx_messageInfo_Task.Size(m)
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetFLock() bool {
	if m != nil {
		return m.FLock
	}
	return false
}

func (m *Task) GetFLockName() string {
	if m != nil {
		return m.FLockName
	}
	return ""
}

func (m *Task) GetFOverride() string {
	if m != nil {
		return m.FOverride
	}
	return ""
}

func (m *Task) GetFDelay() int32 {
	if m != nil {
		return m.FDelay
	}
	return 0
}

func (m *Task) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Task) GetGUID() string {
	if m != nil {
		return m.GUID
	}
	return ""
}

func (m *Task) GetUID() uint32 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *Task) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *Task) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Task) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Task) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Task) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Task) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Task) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *Task) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *Task) GetSystemTime() *duration.Duration {
	if m != nil {
		return m.SystemTime
	}
	return nil
}

func (m *Task) GetUserTime() *duration.Duration {
	if m != nil {
		return m.UserTime
	}
	return nil
}

func (m *Task) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func init() {
	proto.RegisterType((*LogEntry)(nil), "grpc.LogEntry")
	proto.RegisterType((*Task)(nil), "grpc.Task")
}

func init() {
	proto.RegisterFile("gcron.proto", fileDescriptor_fd548e04c98879c7)
}

var fileDescriptor_fd548e04c98879c7 = []byte{
	// 481 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x53, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0xfd, 0xb9, 0x71, 0x12, 0x7b, 0xd2, 0xf6, 0x17, 0x46, 0x08, 0x2d, 0x16, 0x02, 0x2b, 0x27,
	0x9f, 0x5c, 0x54, 0xfe, 0x08, 0x38, 0xb6, 0x49, 0x01, 0x29, 0xa2, 0x95, 0x93, 0x72, 0xdf, 0xda,
	0x8b, 0x65, 0xd5, 0xf6, 0x5a, 0xeb, 0x35, 0x90, 0x1b, 0x9f, 0x8d, 0x4f, 0x86, 0x3c, 0xf6, 0xa6,
	0x11, 0x91, 0xda, 0x03, 0xb7, 0x7d, 0xf3, 0xde, 0xdb, 0x99, 0x9d, 0x99, 0x85, 0x49, 0x1a, 0x2b,
	0x59, 0x86, 0x95, 0x92, 0x5a, 0xa2, 0x9d, 0xaa, 0x2a, 0xf6, 0x9e, 0xa7, 0x52, 0xa6, 0xb9, 0x38,
	0xa1, 0xd8, 0x4d, 0xf3, 0xed, 0xe4, 0x87, 0xe2, 0x55, 0x25, 0x54, 0xdd, 0xa9, 0xbc, 0x17, 0x7f,
	0xf3, 0x3a, 0x2b, 0x44, 0xad, 0x79, 0x51, 0xf5, 0x82, 0xbd, 0x0b, 0x92, 0x46, 0x71, 0x9d, 0x99,
	0x34, 0xb3, 0xb7, 0xe0, 0x2c, 0x65, 0xba, 0x28, 0xb5, 0xda, 0x20, 0x82, 0xfd, 0xf1, 0xfa, 0xf3,
	0x9c, 0x59, 0xbe, 0x15, 0xb8, 0x11, 0x9d, 0xf1, 0x09, 0x8c, 0x2e, 0x1b, 0x5d, 0x35, 0x9a, 0x1d,
	0xf8, 0x56, 0x70, 0x18, 0xf5, 0x68, 0xf6, 0xdb, 0x06, 0x7b, 0xcd, 0xeb, 0x5b, 0x7c, 0x0c, 0xc3,
	0x8b, 0xa5, 0x8c, 0x6f, 0xc9, 0xe5, 0x44, 0x1d, 0xc0, 0x67, 0xe0, 0xd2, 0xe1, 0x0b, 0x2f, 0x04,
	0x39, 0xdd, 0xe8, 0x2e, 0x40, 0xec, 0xe5, 0x77, 0xa1, 0x54, 0x96, 0x08, 0x36, 0xe8, 0x59, 0x13,
	0x68, 0x53, 0x5e, 0xcc, 0x45, 0xce, 0x37, 0xcc, 0xf6, 0xad, 0x60, 0x18, 0xf5, 0x08, 0xa7, 0x30,
	0xb8, 0xca, 0x12, 0x36, 0xa4, 0x60, 0x7b, 0xdc, 0x16, 0x3c, 0xda, 0x29, 0x78, 0x0a, 0x83, 0x36,
	0x34, 0xf6, 0xad, 0xe0, 0x28, 0x1a, 0xf4, 0x4f, 0xb8, 0xe2, 0x4a, 0x94, 0x9a, 0x39, 0xa4, 0xeb,
	0x11, 0x7a, 0xe0, 0x7c, 0x92, 0xb5, 0x2e, 0xdb, 0x12, 0x5d, 0x62, 0xb6, 0xb8, 0xe5, 0xae, 0x6b,
	0xa1, 0x88, 0x83, 0x8e, 0x33, 0x18, 0x19, 0x8c, 0xcf, 0x65, 0x51, 0xf0, 0x32, 0x61, 0x13, 0xa2,
	0x0c, 0xc4, 0x77, 0xe0, 0xae, 0x34, 0x57, 0x7a, 0x9d, 0x15, 0x82, 0x1d, 0xfa, 0x56, 0x30, 0x39,
	0xf5, 0xc2, 0x6e, 0x00, 0xa1, 0x19, 0x40, 0xb8, 0x36, 0x13, 0x8a, 0xee, 0xc4, 0xf8, 0x1a, 0xc6,
	0x8b, 0x32, 0x21, 0xdf, 0xd1, 0x83, 0x3e, 0x23, 0x6d, 0xab, 0x5c, 0xfc, 0xcc, 0xf4, 0xb9, 0x4c,
	0x04, 0x3b, 0xa6, 0xb6, 0x6c, 0xf1, 0xce, 0xe0, 0xfe, 0xdf, 0x1d, 0x1c, 0xbe, 0x07, 0x58, 0x6d,
	0x6a, 0x2d, 0x0a, 0x4a, 0x36, 0xa5, 0x64, 0x4f, 0xf7, 0x92, 0xcd, 0xfb, 0x2d, 0x89, 0x76, 0xc4,
	0xf8, 0xa6, 0x6b, 0x0a, 0x19, 0x1f, 0x3d, 0x64, 0xdc, 0x4a, 0xdb, 0x7e, 0xad, 0x9a, 0x38, 0x16,
	0x75, 0xcd, 0x90, 0x76, 0xc4, 0xc0, 0xd3, 0x5f, 0x07, 0x30, 0xa4, 0x9d, 0xc7, 0x33, 0xb0, 0xbb,
	0xbd, 0xd9, 0xbb, 0x70, 0xa5, 0x55, 0x56, 0xa6, 0x5f, 0x79, 0xde, 0x08, 0x6f, 0xbf, 0x29, 0x67,
	0x52, 0xe6, 0xc4, 0xcd, 0xfe, 0xc3, 0x05, 0x8c, 0x23, 0x91, 0x0b, 0x5e, 0x8b, 0x7f, 0xba, 0xe6,
	0x03, 0x38, 0x34, 0x97, 0xa5, 0x4c, 0xf1, 0x38, 0x6c, 0x7f, 0x61, 0x68, 0x7e, 0xc8, 0xfd, 0xce,
	0xc0, 0xc2, 0x97, 0x60, 0xcf, 0x65, 0x29, 0x10, 0x3a, 0x5f, 0xfb, 0x41, 0xee, 0xf7, 0xdc, 0x8c,
	0x28, 0xfa, 0xea, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x96, 0x20, 0xb6, 0xfc, 0x03, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// GcronClient is the client API for Gcron service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GcronClient interface {
	// Lock remote lock based on (HOSTNAME+USERNAME+UID) or Custom Lock Name
	Lock(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
	// Release release lock based on (HOSTNAME+USERNAME+UID) or Custom Lock Name
	Release(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
	StartLog(ctx context.Context, opts ...grpc.CallOption) (Gcron_StartLogClient, error)
	Done(ctx context.Context, in *Task, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
}

type gcronClient struct {
	cc grpc.ClientConnInterface
}

func NewGcronClient(cc grpc.ClientConnInterface) GcronClient {
	return &gcronClient{cc}
}

func (c *gcronClient) Lock(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/grpc.gcron/Lock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gcronClient) Release(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/grpc.gcron/Release", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gcronClient) StartLog(ctx context.Context, opts ...grpc.CallOption) (Gcron_StartLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Gcron_serviceDesc.Streams[0], "/grpc.gcron/StartLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &gcronStartLogClient{stream}
	return x, nil
}

type Gcron_StartLogClient interface {
	Send(*LogEntry) error
	CloseAndRecv() (*wrappers.BoolValue, error)
	grpc.ClientStream
}

type gcronStartLogClient struct {
	grpc.ClientStream
}

func (x *gcronStartLogClient) Send(m *LogEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gcronStartLogClient) CloseAndRecv() (*wrappers.BoolValue, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(wrappers.BoolValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gcronClient) Done(ctx context.Context, in *Task, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/grpc.gcron/Done", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GcronServer is the server API for Gcron service.
type GcronServer interface {
	// Lock remote lock based on (HOSTNAME+USERNAME+UID) or Custom Lock Name
	Lock(context.Context, *wrappers.StringValue) (*wrappers.BoolValue, error)
	// Release release lock based on (HOSTNAME+USERNAME+UID) or Custom Lock Name
	Release(context.Context, *wrappers.StringValue) (*wrappers.BoolValue, error)
	StartLog(Gcron_StartLogServer) error
	Done(context.Context, *Task) (*wrappers.BoolValue, error)
}

// UnimplementedGcronServer can be embedded to have forward compatible implementations.
type UnimplementedGcronServer struct {
}

func (*UnimplementedGcronServer) Lock(ctx context.Context, req *wrappers.StringValue) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (*UnimplementedGcronServer) Release(ctx context.Context, req *wrappers.StringValue) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Release not implemented")
}
func (*UnimplementedGcronServer) StartLog(srv Gcron_StartLogServer) error {
	return status.Errorf(codes.Unimplemented, "method StartLog not implemented")
}
func (*UnimplementedGcronServer) Done(ctx context.Context, req *Task) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Done not implemented")
}

func RegisterGcronServer(s *grpc.Server, srv GcronServer) {
	s.RegisterService(&_Gcron_serviceDesc, srv)
}

func _Gcron_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GcronServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.gcron/Lock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GcronServer).Lock(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gcron_Release_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GcronServer).Release(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.gcron/Release",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GcronServer).Release(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gcron_StartLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GcronServer).StartLog(&gcronStartLogServer{stream})
}

type Gcron_StartLogServer interface {
	SendAndClose(*wrappers.BoolValue) error
	Recv() (*LogEntry, error)
	grpc.ServerStream
}

type gcronStartLogServer struct {
	grpc.ServerStream
}

func (x *gcronStartLogServer) SendAndClose(m *wrappers.BoolValue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gcronStartLogServer) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Gcron_Done_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GcronServer).Done(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.gcron/Done",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GcronServer).Done(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gcron_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.gcron",
	HandlerType: (*GcronServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lock",
			Handler:    _Gcron_Lock_Handler,
		},
		{
			MethodName: "Release",
			Handler:    _Gcron_Release_Handler,
		},
		{
			MethodName: "Done",
			Handler:    _Gcron_Done_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartLog",
			Handler:       _Gcron_StartLog_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "gcron.proto",
}
